<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Matterhorn — Base Switch + Base Opacity + S2 Cloudless + Relief + Hillshade + Contours</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>

  <!-- MapLibre GL JS 5.9.0 -->
  <link href="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.css" rel="stylesheet"/>
  <script src="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.js"></script>

  <!-- PMTiles v4 -->
  <script src="https://unpkg.com/pmtiles@4.3.0/dist/pmtiles.js"></script>

  <!-- Contours (worker) -->
  <script src="https://unpkg.com/@acalcutt/maplibre-contour-pmtiles@latest/dist/maplibre-contour-pmtiles.min.js"></script>

  <style>
    html, body { margin:0; height:100%; }
    #map { position:absolute; inset:0; }

    .ui {
      position: absolute; top: 10px; left: 10px; z-index: 2;
      background: rgba(255,255,255,.92); border-radius: 10px; padding: 8px 10px;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      display: grid; gap: 8px;
    }

    .toggle-3d {
      appearance: none;
      border: 1px solid #ccc;
      border-radius: 999px;
      padding: 8px;
      font: inherit;
      cursor: pointer;
      background: #fff;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .toggle-3d:hover,
    .toggle-3d:focus-visible {
      outline: none;
      border-color: #111;
    }
    .toggle-3d.active {
      background: #111;
      color: #fff;
      border-color: #111;
    }
    .toggle-3d svg {
      width: 20px;
      height: 20px;
      display: block;
      fill: currentColor;
    }

    .hs-panel {
      position: absolute; top: 10px; right: 10px; z-index: 2;
      background: rgba(255,255,255,.92); border-radius: 10px; padding: 8px 10px;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
    }
    .hs-title { font-weight: 600; margin-bottom: 6px; }
    .btns { display:flex; gap:6px; flex-direction: column; }
    .btns .btn { width: 100%; }
    .btn {
      padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc;
      background:#fff; cursor:pointer; font-size:12px;
    }
    .btn.active { background:#111; color:#fff; border-color:#111; }

    .imagery-toggle {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index:2;
      background: rgba(255,255,255,.92); border-radius: 999px; padding: 6px 8px;
      display: flex; gap: 6px; align-items: center; flex-wrap: wrap; justify-content: center;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      max-width: calc(100% - 20px);
    }
    .pill {
      padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc;
      background:#fff; cursor:pointer; font-size:12px;
    }
    .pill.active { background:#111; color:#fff; border-color:#111; }

    .vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.55) 72%, rgba(0,0,0,0.82) 100%);
      transition: background 0.4s ease;
    }
    .vignette[data-mode="2d"] {
      background: radial-gradient(circle at center, rgba(0,0,0,0) 52%, rgba(0,0,0,0.45) 78%, rgba(0,0,0,0.7) 100%);
    }
    @media (max-width: 640px) {
      .vignette {
        background: radial-gradient(circle at center, rgba(0,0,0,0) 55%, rgba(0,0,0,0.48) 80%, rgba(0,0,0,0.78) 100%);
      }
      .vignette[data-mode="2d"] {
        background: radial-gradient(circle at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 82%, rgba(0,0,0,0.68) 100%);
      }
    }
  </style>
</head>
<body>
<div id="map"></div>
<div class="vignette" aria-hidden="true"></div>

<!-- UI: View mode toggle -->
<div class="ui">
  <button id="toggle3D" class="toggle-3d" type="button" aria-pressed="true" aria-label="Switch to 2D" title="Switch to 2D">
    <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
      <path d="M3.2 18.5h17.6c.7 0 1.2-.6 1.2-1.3a1.2 1.2 0 0 0-.5-.9l-6.9-4.7a1.6 1.6 0 0 0-1.8 0L9.1 14l-6-4a1.2 1.2 0 0 0-1.8.9v6.3c0 .7.5 1.3 1.2 1.3Z"/>
      <path d="M10.2 11.1 7.5 9.3a1.6 1.6 0 0 0-1.8 0L1 12a1.2 1.2 0 0 0 .2 2c.4.2.9.2 1.2 0l4.4-2.9 3.3 2.2 3.5-2.3c.6-.4 1.4-.4 2 0l7.7 5a1.2 1.2 0 0 0 1.8-.9v-.2c0-.4-.2-.8-.6-1L15.3 8a1.6 1.6 0 0 0-1.8 0l-3.3 2.2Z"/>
    </svg>
  </button>
</div>

<!-- Hillshade method switcher -->
<div class="hs-panel">
  <div class="hs-title">Hillshade method</div>
  <div class="btns">
    <button class="btn active" data-method="igor">Igor</button>
    <button class="btn" data-method="combined">Combined</button>
  </div>
</div>

<!-- Imagery toggle -->
<div class="imagery-toggle">
  <button class="pill" id="toggleS2">S2 Cloudless</button>
</div>

<script>
  // ---------- CONFIG ----------
  const RELIEF_OPACITY = 0.40;
  const S2_OPACITY = 0.50;
  const VERSATILES_LOCAL_JSON = './osm_liberty.json'; // place alongside this HTML
  const S2C_URL = 'https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2020_3857/default/g/{z}/{y}/{x}.jpg';
  const TILE_FADE_DURATION = 800;
  const S2_FADE_DURATION = 700;
  const SKY_SETTINGS = {
    'sky-color': '#bcd0e6',
    'sky-horizon-blend': 0.35,
    'horizon-color': '#e6effa',
    'horizon-fog-blend': 0.35,
    'fog-color': '#bcd0e6',
    'fog-ground-blend': 0.15
  };
  const VIEW_MODES = { THREED: '3d', TWOD: '2d' };
  const DEFAULT_3D_ORIENTATION = { pitch: 60, bearing: -18.6 };

  // Ensure SW is ready (needed for contour DEM proxy)
  async function waitForSWReady() {
    if (!('serviceWorker' in navigator)) return;
    try { await navigator.serviceWorker.register('./sw.js', { scope: './' }); } catch {}
    await navigator.serviceWorker.ready;
    if (!navigator.serviceWorker.controller) { location.reload(); await new Promise(()=>{}); }
  }

  (async () => {
    await waitForSWReady();

    // Mapterhorn protocol for DEM
    const pmProto = new pmtiles.Protocol({ metadata: true, errorOnMissingTile: true });
    maplibregl.addProtocol('mapterhorn', async (params, abortController) => {
      const [z, x, y] = params.url.replace('mapterhorn://', '').split('/').map(Number);
      const name = z <= 12 ? 'planet' : `6-${x >> (z - 6)}-${y >> (z - 6)}`;
      const url = `pmtiles://https://download.mapterhorn.com/${name}.pmtiles/${z}/${x}/${y}.webp`;
      const resp = await pmProto.tile({ ...params, url }, abortController);
      if (resp.data === null) throw new Error(`Tile z=${z} x=${x} y=${y} not found.`);
      return resp;
    });

    // Load VersaTiles style upfront so we can patch glyphs/sprite
    const versaStyle = await fetch(VERSATILES_LOCAL_JSON, { cache: 'no-store' }).then(r => r.json());
    versaStyle.glyphs = 'https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf';
    if ('sprite' in versaStyle) delete versaStyle.sprite;

    // Map init with VersaTiles
    const map = new maplibregl.Map({
      container: 'map',
      hash: true,
      center: [7.6586, 45.9763],
      zoom: 11.7,
      pitch: DEFAULT_3D_ORIENTATION.pitch,
      bearing: DEFAULT_3D_ORIENTATION.bearing,
      style: versaStyle,
      maxZoom: 18,
      maxPitch: 85,
      fadeDuration: TILE_FADE_DURATION
    });

    // Silence missing sprite warnings
    map.on('styleimagemissing', (e) => {
      if (map.hasImage(e.id)) return;
      const data = new Uint8Array([0,0,0,0]);
      map.addImage(e.id, { width:1, height:1, data });
    });

    // Contour DEM via SW
    const PROXY_ABS = `${window.location.origin}/mapterhorn-dem/{z}/{x}/{y}`;
    const demSource = new mlcontour.DemSource({
      url: PROXY_ABS, encoding: 'terrarium', maxzoom: 12, worker: true
    });
    demSource.setupMaplibre(maplibregl);

    // Helper: set opacity across base style layers (not our overlays)
    function setBaseStyleOpacity(map, alpha) {
      const style = map.getStyle();
      if (!style || !style.layers) return;
      for (const layer of style.layers) {
        const id = layer.id;
        const type = layer.type;

        // Skip our custom overlays so they keep independent controls
        if (['s2cloudless','color-relief','hillshade','contours','contour-text'].includes(id)) continue;

        const setIf = (prop, value) => {
          try {
            const cur = map.getPaintProperty(id, prop);
            if (cur !== undefined) map.setPaintProperty(id, prop, value);
          } catch (_) {}
        };

        switch (type) {
          case 'background': setIf('background-opacity', alpha); break;
          case 'fill': setIf('fill-opacity', alpha); break;
          case 'line': setIf('line-opacity', alpha); break;
          case 'symbol': setIf('text-opacity', alpha); setIf('icon-opacity', alpha); break;
          case 'circle': setIf('circle-opacity', alpha); break;
          case 'fill-extrusion': setIf('fill-extrusion-opacity', alpha); break;
          case 'heatmap': setIf('heatmap-opacity', alpha); break;
          case 'raster': setIf('raster-opacity', alpha); break;
          default: break;
        }
      }
    }

    // Overlay re-apply (clean, then add; contours always under topmost label)
    let currentViewMode = VIEW_MODES.THREED;
    let last3DOrientation = { ...DEFAULT_3D_ORIENTATION };
    const vignetteEl = document.querySelector('.vignette');
    const viewToggleBtn = document.getElementById('toggle3D');

    function updateViewToggle(mode) {
      if (!viewToggleBtn) return;
      const is3D = mode === VIEW_MODES.THREED;
      viewToggleBtn.classList.toggle('active', is3D);
      const nextLabel = is3D ? 'Switch to 2D' : 'Switch to 3D';
      viewToggleBtn.setAttribute('aria-pressed', String(is3D));
      viewToggleBtn.setAttribute('aria-label', nextLabel);
      viewToggleBtn.setAttribute('title', nextLabel);
    }

    function syncTerrainAndSky() {
      if (currentViewMode === VIEW_MODES.THREED) {
        if (map.getSource('terrainSource')) {
          map.setTerrain({ source: 'terrainSource', exaggeration: 1 });
        }
        map.setSky(SKY_SETTINGS);
      } else {
        map.setTerrain(null);
        map.setSky(null);
      }
      if (vignetteEl) vignetteEl.dataset.mode = currentViewMode;
    }

    const PEAK_POINTER_ID = 'peak-pointer';

    function createPeakPointerImage(color = '#3ab7c6') {
      const width = 48;
      const height = 96;
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);

      const centerX = width / 2;
      const topOffset = 8;
      const stemWidth = width * 0.16;
      ctx.strokeStyle = color;
      ctx.lineWidth = stemWidth;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(centerX, topOffset);
      ctx.lineTo(centerX, height - width * 0.28);
      ctx.stroke();

      ctx.fillStyle = color;
      const tipRadius = width * 0.24;
      ctx.beginPath();
      ctx.arc(centerX, height - tipRadius, tipRadius, 0, Math.PI * 2);
      ctx.fill();

      return ctx.getImageData(0, 0, width, height);
    }

    function ensurePeakPointerImage(map) {
      if (map.hasImage(PEAK_POINTER_ID)) return;
      const pointerImage = createPeakPointerImage();
      map.addImage(PEAK_POINTER_ID, pointerImage, { pixelRatio: 2 });
    }

    function updatePeakLabelLayer(map, layerId) {
      if (!map.getLayer(layerId)) return;
      ensurePeakPointerImage(map);

      const textField = [
        'format',
        ['coalesce', ['get', 'name:en'], ['get', 'name']],
        { 'font-scale': 1 },
        '\n',
        {},
        ['concat', ['number-format', ['get', 'ele'], { 'maximumFractionDigits': 0 }], ' m'],
        { 'font-scale': 0.85 }
      ];

      map.setLayoutProperty(layerId, 'icon-image', PEAK_POINTER_ID);
      map.setLayoutProperty(layerId, 'icon-size', 0.42);
      map.setLayoutProperty(layerId, 'icon-anchor', 'top');
      map.setLayoutProperty(layerId, 'icon-offset', [0, 0]);
      map.setLayoutProperty(layerId, 'text-anchor', 'bottom');
      map.setLayoutProperty(layerId, 'text-offset', [0, -1.4]);
      map.setLayoutProperty(layerId, 'text-field', textField);
      map.setLayoutProperty(layerId, 'text-font', ['Noto Sans Bold']);
      map.setLayoutProperty(layerId, 'text-line-height', 1.15);
      map.setLayoutProperty(layerId, 'symbol-spacing', 250);
      map.setLayoutProperty(layerId, 'text-max-width', 6);

      map.setPaintProperty(layerId, 'icon-opacity', 0.9);
      map.setPaintProperty(layerId, 'text-color', '#133540');
      map.setPaintProperty(layerId, 'text-halo-color', 'rgba(255,255,255,0.95)');
      map.setPaintProperty(layerId, 'text-halo-width', 2.2);
      map.setPaintProperty(layerId, 'text-halo-blur', 0.4);
    }

    function updatePeakLabels(map) {
      updatePeakLabelLayer(map, 'Mountain peak labels');
      updatePeakLabelLayer(map, 'Volcano peak labels');
    }

    function applyViewMode(mode, { animate = true } = {}) {
      if (mode === currentViewMode && animate) {
        // Already in requested mode; still ensure UI reflects state.
        updateViewToggle(mode);
        if (vignetteEl) vignetteEl.dataset.mode = currentViewMode;
        return;
      }

      const is3D = mode === VIEW_MODES.THREED;
      if (!is3D) {
        last3DOrientation = {
          pitch: map.getPitch(),
          bearing: map.getBearing()
        };
      }

      currentViewMode = mode;
      updateViewToggle(mode);
      if (vignetteEl) vignetteEl.dataset.mode = mode;

      const targetOrientation = is3D ? last3DOrientation : { pitch: 0, bearing: 0 };
      if (animate) {
        map.easeTo({
          pitch: targetOrientation.pitch,
          bearing: targetOrientation.bearing,
          duration: 1000
        });
      } else {
        map.setPitch(targetOrientation.pitch);
        map.setBearing(targetOrientation.bearing);
      }

      if (map.dragRotate && typeof map.dragRotate[is3D ? 'enable' : 'disable'] === 'function') {
        map.dragRotate[is3D ? 'enable' : 'disable']();
      }
      if (map.touchZoomRotate && typeof map.touchZoomRotate[is3D ? 'enableRotation' : 'disableRotation'] === 'function') {
        map.touchZoomRotate[is3D ? 'enableRotation' : 'disableRotation']();
      }

      syncTerrainAndSky();
    }

    if (viewToggleBtn) {
      viewToggleBtn.addEventListener('click', () => {
        const nextMode = currentViewMode === VIEW_MODES.THREED ? VIEW_MODES.TWOD : VIEW_MODES.THREED;
        applyViewMode(nextMode);
      });
    }

    if (vignetteEl) {
      vignetteEl.dataset.mode = currentViewMode;
    }
    updateViewToggle(currentViewMode);

    async function applyOverlays() {
      const rmL = id => { if (map.getLayer(id)) map.removeLayer(id); };
      const rmS = id => { if (map.getSource(id)) map.removeSource(id); };

      // Topmost label (symbol) layer id
      const liveLayers = map.getStyle().layers || [];
      let topLabelId = null;
      for (let i = liveLayers.length - 1; i >= 0; i--) {
        if (liveLayers[i].type === 'symbol') { topLabelId = liveLayers[i].id; break; }
      }

      // Remove layers first, then sources
      rmL('contour-text'); rmL('contours');
      rmL('hillshade'); rmL('color-relief');
      rmL('s2cloudless');
      rmS('contours'); rmS('hillshadeSource'); rmS('reliefDem'); rmS('terrainSource');
      rmS('s2cloudless');

      // Sources
      map.addSource('terrainSource', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512,
        attribution: '<a href="https://mapterhorn.com/attribution">© Mapterhorn</a>'
      });
      map.addSource('hillshadeSource', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512,
        attribution: '<a href="https://mapterhorn.com/attribution">© Mapterhorn</a>'
      });
      map.addSource('reliefDem', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512
      });

      // Sentinel-2 Cloudless (EOX) raster overlay
      map.addSource('s2cloudless', {
        type: 'raster',
        tiles: [S2C_URL],
        tileSize: 256,
        attribution: '<a href="https://s2maps.eu/">© Sentinel-2 cloudless by EOX IT Services GmbH</a>'
      });

      // Imagery below relief/hillshade so those effects read on top
      map.addLayer({
        id: 's2cloudless',
        type: 'raster',
        source: 's2cloudless',
        paint: {
          'raster-opacity': S2_OPACITY,
          'raster-resampling': 'linear',
          'raster-fade-duration': S2_FADE_DURATION
        }
      }, topLabelId || undefined);

      // Color relief
      map.addLayer({
        id: 'color-relief',
        type: 'color-relief',
        source: 'reliefDem',
        paint: {
          'color-relief-color': [
            'interpolate', ['linear'], ['elevation'],
            0, '#254a38', 400, '#2f6b4a', 800, '#5b8f5f',
            1200, '#7fa36e', 1600, '#9eb17b',
            2000, '#b9bf8a', 2300, '#c9c38f',
            2600, '#b6ab93', 2900, '#9e978e', 3200, '#8a8a8a',
            3500, '#aeb6c0', 3800, '#cfd6de', 4100, '#f2f3f5'
          ],
          'color-relief-opacity': RELIEF_OPACITY
        }
      }, topLabelId || undefined);

      // Hillshade (anchored to map)
      map.addLayer({
        id: 'hillshade',
        type: 'hillshade',
        source: 'hillshadeSource',
        paint: {
          'hillshade-illumination-anchor': 'map',
          'hillshade-illumination-direction': [270, 315, 0, 45],
          'hillshade-illumination-altitude': [30, 30, 30, 30],
          'hillshade-exaggeration': 0.22,
          'hillshade-highlight-color': 'rgba(255,255,255,0.85)',
          'hillshade-shadow-color':   'rgba(0,0,0,0.55)'
        }
      }, topLabelId || undefined);

      // Contours
      map.addSource('contours', {
        type: 'vector',
        tiles: [
          demSource.contourProtocolUrl({
            multiplier: 1,
            thresholds: { 11:[60,300], 12:[30,150], 13:[30,150], 14:[15,60], 15:[6,30] },
            elevationKey: 'ele', levelKey: 'level', contourLayer: 'contours'
          })
        ],
        maxzoom: 16
      });

      map.addLayer({
        id: 'contours',
        type: 'line',
        source: 'contours',
        'source-layer': 'contours',
        layout: { 'line-join': 'round' },
        paint: {
          'line-color': 'rgba(0,0,0,0.55)',
          'line-width': ['match', ['get', 'level'], 1, 1, 0.5],
          'line-opacity': ['interpolate', ['linear'], ['zoom'], 13.4, 0, 13.5, 0.45, 15, 0.85, 17, 1]
        }
      });
      map.addLayer({
        id: 'contour-text',
        type: 'symbol',
        source: 'contours',
        'source-layer': 'contours',
        filter: ['>', ['get', 'level'], 0],
        layout: {
          'symbol-placement': 'line',
          'text-anchor': 'center',
          'text-size': 10,
          'text-field': ['concat', ['number-format', ['get', 'ele'], { 'maximumFractionDigits': 0 }], ' m'],
          'text-font': ['Noto Sans Bold']
        },
        paint: {
          'text-halo-color': 'white',
          'text-halo-width': 1,
          'text-opacity': ['interpolate', ['linear'], ['zoom'], 13.4, 0, 13.6, 0.5, 14.2, 0.9]
        }
      });
      if (topLabelId) {
        map.moveLayer('contours', topLabelId);
        map.moveLayer('contour-text', topLabelId);
      }

      const symbolLayers = (map.getStyle().layers || []).filter(l => l.type === 'symbol');
      symbolLayers.forEach(l => map.moveLayer(l.id));

      // Sky/Fog / Terrain sync with view mode
      syncTerrainAndSky();

      // Reflect S2 toggle state
      const s2Btn = document.getElementById('toggleS2');
      if (s2Btn) {
        const vis = (map.getLayoutProperty('s2cloudless', 'visibility') || 'visible') !== 'none';
        s2Btn.classList.toggle('active', vis);
      }

      // Apply current base opacity to all base layers after style is ready
      setBaseStyleOpacity(map, 1);
      updatePeakLabels(map);
    }

    // After the style loads, wire overlays
    map.on('style.load', applyOverlays);

    // Hillshade method switcher
    const methodButtons = Array.from(document.querySelectorAll('.btn'));
    const DEFAULT_METHOD = 'igor';
    function setHillshadeMethod(method) {
      methodButtons.forEach(b => b.classList.toggle('active', b.dataset.method === method));
      if (!map.getLayer('hillshade')) return;

      map.setPaintProperty('hillshade', 'hillshade-illumination-anchor', 'map');
      map.setPaintProperty('hillshade', 'hillshade-illumination-direction', [270, 315, 0, 45]);
      map.setPaintProperty('hillshade', 'hillshade-illumination-altitude', [30, 30, 30, 30]);
      map.setPaintProperty('hillshade', 'hillshade-method', method);

      if (method === 'combined') {
        map.setPaintProperty('hillshade', 'hillshade-exaggeration', 0.23);
        map.setPaintProperty('hillshade', 'hillshade-highlight-color', 'rgba(255,255,255,0.88)');
        map.setPaintProperty('hillshade', 'hillshade-shadow-color',   'rgba(0,0,0,0.58)');
      } else { // igor
        map.setPaintProperty('hillshade', 'hillshade-exaggeration', 0.24);
        map.setPaintProperty('hillshade', 'hillshade-highlight-color', 'rgba(255,255,255,0.9)');
        map.setPaintProperty('hillshade', 'hillshade-shadow-color',   'rgba(0,0,0,0.6)');
      }
    }
    methodButtons.forEach(btn => btn.addEventListener('click', () => setHillshadeMethod(btn.dataset.method)));
    map.once('style.load', () => setHillshadeMethod(DEFAULT_METHOD));

    // Ensure initial mode is synced without animation once map is ready
    map.once('style.load', () => applyViewMode(currentViewMode, { animate: false }));

    // S2 Cloudless toggle
    const s2Btn = document.getElementById('toggleS2');
    if (s2Btn) {
      s2Btn.addEventListener('click', () => {
        if (!map.getLayer('s2cloudless')) return;
        const vis = map.getLayoutProperty('s2cloudless', 'visibility') || 'visible';
        const next = vis === 'none' ? 'visible' : 'none';
        map.setLayoutProperty('s2cloudless', 'visibility', next);
        s2Btn.classList.toggle('active', next === 'visible');
      });
    }
    // Initial base is VersaTiles; overlays apply on first style.load.
  })();
</script>
</body>
</html>
