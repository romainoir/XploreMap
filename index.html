<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Matterhorn — Base Switch + Base Opacity + S2 Cloudless + Relief + Hillshade + Contours</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>

  <!-- MapLibre GL JS 5.9.0 -->
  <link href="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.css" rel="stylesheet"/>
  <script src="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.js"></script>

  <!-- PMTiles v4 -->
  <script src="https://unpkg.com/pmtiles@4.3.0/dist/pmtiles.js"></script>

  <!-- Contours (worker) -->
  <script src="https://unpkg.com/@acalcutt/maplibre-contour-pmtiles@latest/dist/maplibre-contour-pmtiles.min.js"></script>

  <style>
    html, body { margin:0; height:100%; }
    #map { position:absolute; inset:0; }

    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .maplibre-preload {
      position: absolute;
      inset: 0;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #f6fbff;
      font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      transition: opacity 0.35s ease;
      pointer-events: none;
    }

    .maplibre-preload__content {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 22px;
      border-radius: 999px;
      background: rgba(5, 14, 22, 0.65);
      box-shadow: 0 12px 32px rgba(0, 0, 0, 0.35);
      pointer-events: auto;
    }

    .maplibre-preload__spinner {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid rgba(255, 255, 255, 0.25);
      border-top-color: #3ab7c6;
      animation: maplibre-preload-spin 1s linear infinite;
    }

    .maplibre-preload__text {
      font-weight: 600;
      letter-spacing: 0.16em;
      font-size: 12px;
    }

    .maplibre-preload--hidden {
      opacity: 0;
    }

    @keyframes maplibre-preload-spin {
      to { transform: rotate(360deg); }
    }

    @media (prefers-reduced-motion: reduce) {
      .maplibre-preload { transition: none; }
      .maplibre-preload__spinner { animation: none; }
    }

    .ui {
      position: absolute; top: 10px; left: 10px; z-index: 2;
      background: rgba(255,255,255,.92); border-radius: 10px; padding: 8px 10px;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      display: grid; gap: 8px;
    }

    .toggle-3d {
      appearance: none;
      border: 1px solid #ccc;
      border-radius: 999px;
      padding: 8px;
      font: inherit;
      cursor: pointer;
      background: #fff;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .toggle-3d:hover,
    .toggle-3d:focus-visible {
      outline: none;
      border-color: #111;
    }
    .toggle-3d.active {
      background: #111;
      color: #fff;
      border-color: #111;
    }
    .toggle-3d svg {
      width: 20px;
      height: 20px;
      display: block;
      fill: currentColor;
    }

    .gpx-import {
      display: flex;
      justify-content: center;
    }

    .gpx-import .btn {
      width: 100%;
      text-align: center;
    }

    #gpxFileInput {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .hs-panel {
      position: absolute; top: 10px; right: 10px; z-index: 2;
      background: rgba(255,255,255,.92); border-radius: 10px; padding: 8px 10px;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
    }
    .hs-title { font-weight: 600; margin-bottom: 6px; }
    .btns { display:flex; gap:6px; flex-direction: column; }
    .btns .btn { width: 100%; }
    .btn {
      padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc;
      background:#fff; cursor:pointer; font-size:12px;
    }
    .btn.active { background:#111; color:#fff; border-color:#111; }

    .imagery-toggle {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index:2;
      background: rgba(255,255,255,.92); border-radius: 999px; padding: 6px 8px;
      display: flex; gap: 6px; align-items: center; flex-wrap: wrap; justify-content: center;
      font: 13px/1.2 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      box-shadow: 0 6px 18px rgba(0,0,0,.12);
      max-width: calc(100% - 20px);
    }
    .pill {
      padding: 6px 10px; border-radius: 999px; border: 1px solid #ccc;
      background:#fff; cursor:pointer; font-size:12px;
    }
    .pill.active { background:#111; color:#fff; border-color:#111; }

    .vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 45%, rgba(0,0,0,0.55) 72%, rgba(0,0,0,0.82) 100%);
      transition: background 0.4s ease;
    }
    .vignette[data-mode="2d"] {
      background: radial-gradient(circle at center, rgba(0,0,0,0) 52%, rgba(0,0,0,0.45) 78%, rgba(0,0,0,0.7) 100%);
    }
    @media (max-width: 640px) {
      .vignette {
        background: radial-gradient(circle at center, rgba(0,0,0,0) 55%, rgba(0,0,0,0.48) 80%, rgba(0,0,0,0.78) 100%);
      }
      .vignette[data-mode="2d"] {
        background: radial-gradient(circle at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.4) 82%, rgba(0,0,0,0.68) 100%);
      }
    }
  </style>
  <script src="./maplibre-preload.js"></script>
</head>
<body>
<div id="map"></div>
<div class="vignette" aria-hidden="true"></div>

<!-- UI: View mode toggle -->
<div class="ui">
  <button id="toggle3D" class="toggle-3d" type="button" aria-pressed="true" aria-label="Switch to 2D" title="Switch to 2D">
    <svg viewBox="0 0 24 24" role="img" aria-hidden="true" focusable="false">
      <path d="M3.2 18.5h17.6c.7 0 1.2-.6 1.2-1.3a1.2 1.2 0 0 0-.5-.9l-6.9-4.7a1.6 1.6 0 0 0-1.8 0L9.1 14l-6-4a1.2 1.2 0 0 0-1.8.9v6.3c0 .7.5 1.3 1.2 1.3Z"/>
      <path d="M10.2 11.1 7.5 9.3a1.6 1.6 0 0 0-1.8 0L1 12a1.2 1.2 0 0 0 .2 2c.4.2.9.2 1.2 0l4.4-2.9 3.3 2.2 3.5-2.3c.6-.4 1.4-.4 2 0l7.7 5a1.2 1.2 0 0 0 1.8-.9v-.2c0-.4-.2-.8-.6-1L15.3 8a1.6 1.6 0 0 0-1.8 0l-3.3 2.2Z"/>
    </svg>
  </button>
  <input id="gpxFileInput" class="sr-only" type="file" accept=".gpx,application/gpx+xml">
  <div class="gpx-import">
    <button id="gpxImportButton" class="btn" type="button">Import GPX</button>
  </div>
</div>

<!-- Hillshade method switcher -->
<div class="hs-panel">
  <div class="hs-title">Hillshade method</div>
  <div class="btns">
    <button class="btn active" data-method="igor">Igor</button>
    <button class="btn" data-method="combined">Combined</button>
  </div>
</div>

<!-- Imagery toggle -->
<div class="imagery-toggle">
  <button class="pill" id="toggleS2">S2 Cloudless</button>
</div>

<script>
  // ---------- CONFIG ----------
  const RELIEF_OPACITY = 0.40;
  const S2_OPACITY = 0.50;
  const VERSATILES_LOCAL_JSON = './osm_liberty.json'; // place alongside this HTML
  const S2C_URL = 'https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2020_3857/default/g/{z}/{y}/{x}.jpg';
  const TILE_FADE_DURATION = 800;
  const S2_FADE_DURATION = 700;
  function getTextContent(el, tagName) {
    if (!el) return null;
    const child = el.getElementsByTagName(tagName)[0];
    if (!child || !child.textContent) return null;
    const text = child.textContent.trim();
    return text.length ? text : null;
  }

  function parsePointElement(el, latAttr = 'lat', lonAttr = 'lon') {
    if (!el) return null;
    const lat = parseFloat(el.getAttribute(latAttr));
    const lon = parseFloat(el.getAttribute(lonAttr));
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
    const coord = [lon, lat];
    const eleText = getTextContent(el, 'ele');
    const ele = eleText !== null ? parseFloat(eleText) : NaN;
    if (Number.isFinite(ele)) coord.push(ele);
    return coord;
  }

  function parseGpxToGeoJson(gpxText) {
    if (!gpxText) return null;
    const parser = new DOMParser();
    const doc = parser.parseFromString(gpxText, 'application/xml');
    if (!doc || doc.getElementsByTagName('parsererror').length) {
      throw new Error('Invalid GPX document');
    }

    const features = [];

    const appendLineFeature = (coordinates, properties = {}) => {
      if (!Array.isArray(coordinates) || coordinates.length < 2) return;
      features.push({
        type: 'Feature',
        geometry: { type: 'LineString', coordinates },
        properties
      });
    };

    const appendMultiLineFeature = (segments, properties = {}) => {
      const validSegments = segments.filter(segment => Array.isArray(segment) && segment.length >= 2);
      if (!validSegments.length) return;
      if (validSegments.length === 1) {
        appendLineFeature(validSegments[0], properties);
        return;
      }
      features.push({
        type: 'Feature',
        geometry: { type: 'MultiLineString', coordinates: validSegments },
        properties
      });
    };

    const appendPointFeature = (coord, properties = {}) => {
      if (!Array.isArray(coord) || coord.length < 2) return;
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: coord },
        properties
      });
    };

    const trackElements = Array.from(doc.getElementsByTagName('trk'));
    trackElements.forEach((trackEl, trackIndex) => {
      const trackName = getTextContent(trackEl, 'name') || `Track ${trackIndex + 1}`;
      const segments = Array.from(trackEl.getElementsByTagName('trkseg'));
      const segmentCoords = [];
      segments.forEach((segmentEl, segIndex) => {
        const points = Array.from(segmentEl.getElementsByTagName('trkpt'));
        const coords = points
          .map(pt => parsePointElement(pt))
          .filter(coord => Array.isArray(coord));
        if (coords.length >= 2) {
          segmentCoords.push(coords);
        } else if (coords.length === 1) {
          appendPointFeature(coords[0], { name: trackName, source: 'track', segment: segIndex + 1 });
        }
      });
      appendMultiLineFeature(segmentCoords, { name: trackName, source: 'track' });
    });

    const routeElements = Array.from(doc.getElementsByTagName('rte'));
    routeElements.forEach((routeEl, routeIndex) => {
      const routeName = getTextContent(routeEl, 'name') || `Route ${routeIndex + 1}`;
      const points = Array.from(routeEl.getElementsByTagName('rtept'));
      const coords = points
        .map(pt => parsePointElement(pt))
        .filter(coord => Array.isArray(coord));
      appendLineFeature(coords, { name: routeName, source: 'route' });
    });

    const waypointElements = Array.from(doc.getElementsByTagName('wpt'));
    waypointElements.forEach((wptEl, waypointIndex) => {
      const coord = parsePointElement(wptEl);
      if (!coord) return;
      const name = getTextContent(wptEl, 'name') || `Waypoint ${waypointIndex + 1}`;
      appendPointFeature(coord, { name, source: 'waypoint' });
    });

    return {
      type: 'FeatureCollection',
      features
    };
  }

  function computeGeojsonBounds(geojson) {
    if (!geojson || geojson.type !== 'FeatureCollection') return null;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;

    const extend = (coord) => {
      if (!Array.isArray(coord) || coord.length < 2) return;
      const [x, y] = coord;
      if (!Number.isFinite(x) || !Number.isFinite(y)) return;
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    };

    const walk = (coords) => {
      if (!Array.isArray(coords)) return;
      if (typeof coords[0] === 'number') {
        extend(coords);
        return;
      }
      coords.forEach(walk);
    };

    (geojson.features || []).forEach(feature => {
      if (!feature || !feature.geometry) return;
      walk(feature.geometry.coordinates);
    });

    if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) {
      return null;
    }
    return [[minX, minY], [maxX, maxY]];
  }

  function ensureGpxLayers(map, data, beforeLayerId) {
    if (!map) return;
    const emptyCollection = { type: 'FeatureCollection', features: [] };
    const dataset = data && Array.isArray(data.features) ? data : emptyCollection;

    const existingSource = map.getSource(GPX_SOURCE_ID);
    if (existingSource) {
      existingSource.setData(dataset);
    } else if (typeof map.addSource === 'function') {
      map.addSource(GPX_SOURCE_ID, {
        type: 'geojson',
        data: dataset
      });
    }

    const before = beforeLayerId || undefined;

    if (!map.getLayer(GPX_LINE_LAYER_ID)) {
      map.addLayer({
        id: GPX_LINE_LAYER_ID,
        type: 'line',
        source: GPX_SOURCE_ID,
        filter: ['match', ['geometry-type'], ['LineString', 'MultiLineString'], true, false],
        layout: {
          'line-cap': 'round',
          'line-join': 'round'
        },
        paint: {
          'line-color': '#ff6b3a',
          'line-width': ['interpolate', ['linear'], ['zoom'], 10, 2.4, 12, 3.6, 14, 5.2, 16, 7.5],
          'line-opacity': 0.9
        }
      }, before);
    } else if (before) {
      try { map.moveLayer(GPX_LINE_LAYER_ID, before); } catch (_) {}
    }

    if (!map.getLayer(GPX_POINT_LAYER_ID)) {
      map.addLayer({
        id: GPX_POINT_LAYER_ID,
        type: 'circle',
        source: GPX_SOURCE_ID,
        filter: ['==', ['geometry-type'], 'Point'],
        paint: {
          'circle-radius': ['interpolate', ['linear'], ['zoom'], 8, 4, 12, 5.5, 16, 8],
          'circle-color': '#ffffff',
          'circle-opacity': 0.95,
          'circle-stroke-color': '#ff6b3a',
          'circle-stroke-width': ['interpolate', ['linear'], ['zoom'], 8, 1.2, 12, 1.6, 16, 2.4]
        }
      }, before);
    } else if (before) {
      try { map.moveLayer(GPX_POINT_LAYER_ID, before); } catch (_) {}
    }
  }

  function zoomToGeojson(map, geojson) {
    if (!map || !geojson) return;
    const bounds = computeGeojsonBounds(geojson);
    if (!bounds) return;
    const [[minX, minY], [maxX, maxY]] = bounds;
    if (minX === maxX && minY === maxY) {
      const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : 13;
      const targetZoom = Number.isFinite(currentZoom) ? Math.max(13, currentZoom) : 13;
      map.flyTo({ center: [minX, minY], zoom: targetZoom });
      return;
    }
    map.fitBounds(bounds, {
      padding: { top: 80, bottom: 80, left: 80, right: 80 },
      maxZoom: 15,
      duration: 1200
    });
  }
  const SKY_SETTINGS = {
    'sky-color': '#bcd0e6',
    'sky-horizon-blend': 0.35,
    'horizon-color': '#e6effa',
    'horizon-fog-blend': 0.35,
    'fog-color': '#bcd0e6',
    'fog-ground-blend': 0.15
  };
  const VIEW_MODES = { THREED: '3d', TWOD: '2d' };
  const DEFAULT_3D_ORIENTATION = { pitch: 60, bearing: -18.6 };
  const GPX_SOURCE_ID = 'imported-gpx';
  const GPX_LINE_LAYER_ID = 'imported-gpx-line';
  const GPX_POINT_LAYER_ID = 'imported-gpx-points';

  // Ensure SW is ready (needed for contour DEM proxy)
  async function waitForSWReady() {
    if (!('serviceWorker' in navigator)) return;
    try { await navigator.serviceWorker.register('./sw.js', { scope: './' }); } catch {}
    await navigator.serviceWorker.ready;
    if (!navigator.serviceWorker.controller) { location.reload(); await new Promise(()=>{}); }
  }

  (async () => {
    await waitForSWReady();

    // Mapterhorn protocol for DEM
    const pmProto = new pmtiles.Protocol({ metadata: true, errorOnMissingTile: true });
    maplibregl.addProtocol('mapterhorn', async (params, abortController) => {
      const [z, x, y] = params.url.replace('mapterhorn://', '').split('/').map(Number);
      const name = z <= 12 ? 'planet' : `6-${x >> (z - 6)}-${y >> (z - 6)}`;
      const url = `pmtiles://https://download.mapterhorn.com/${name}.pmtiles/${z}/${x}/${y}.webp`;
      const resp = await pmProto.tile({ ...params, url }, abortController);
      if (resp.data === null) throw new Error(`Tile z=${z} x=${x} y=${y} not found.`);
      return resp;
    });

    // Load VersaTiles style upfront so we can patch glyphs/sprite
    const versaStyle = await fetch(VERSATILES_LOCAL_JSON, { cache: 'no-store' }).then(r => r.json());
    versaStyle.glyphs = 'https://tiles.openfreemap.org/fonts/{fontstack}/{range}.pbf';
    if ('sprite' in versaStyle) delete versaStyle.sprite;

    // Map init with VersaTiles
    const map = new maplibregl.Map({
      container: 'map',
      hash: true,
      center: [7.6586, 45.9763],
      zoom: 11.7,
      pitch: DEFAULT_3D_ORIENTATION.pitch,
      bearing: DEFAULT_3D_ORIENTATION.bearing,
      style: versaStyle,
      maxZoom: 18,
      maxPitch: 85,
      fadeDuration: TILE_FADE_DURATION
    });

    maplibrePreload(map, {
      text: 'Preparing Matterhorn…',
      minDuration: 600,
      background: 'linear-gradient(135deg, rgba(5,15,24,0.92) 0%, rgba(6,24,36,0.92) 50%, rgba(10,34,46,0.92) 100%)'
    });

    let currentGpxData = null;
    const gpxFileInput = document.getElementById('gpxFileInput');
    const gpxImportButton = document.getElementById('gpxImportButton');

    function applyGpxData(geojson) {
      currentGpxData = geojson;
      const applyLayers = () => {
        ensureGpxLayers(map, currentGpxData);
        if (geojson && geojson.features && geojson.features.length) {
          zoomToGeojson(map, geojson);
        }
      };
      if (typeof map.isStyleLoaded === 'function' && !map.isStyleLoaded()) {
        map.once('style.load', applyLayers);
      } else {
        applyLayers();
      }
    }

    if (gpxImportButton && gpxFileInput) {
      gpxImportButton.addEventListener('click', () => {
        gpxFileInput.click();
      });

      gpxFileInput.addEventListener('change', async () => {
        const file = gpxFileInput.files && gpxFileInput.files[0];
        if (!file) return;
        try {
          const text = await file.text();
          const geojson = parseGpxToGeoJson(text);
          if (!geojson || !geojson.features || geojson.features.length === 0) {
            window.alert('No GPX features were found in the selected file.');
          } else {
            applyGpxData(geojson);
          }
        } catch (error) {
          console.error('Failed to import GPX file', error);
          window.alert('Unable to load the selected GPX file. Please ensure it is valid.');
        } finally {
          gpxFileInput.value = '';
        }
      });
    }

    // Silence missing sprite warnings
    map.on('styleimagemissing', (e) => {
      if (map.hasImage(e.id)) return;
      const data = new Uint8Array([0,0,0,0]);
      map.addImage(e.id, { width:1, height:1, data });
    });

    // Contour DEM via SW
    const PROXY_ABS = `${window.location.origin}/mapterhorn-dem/{z}/{x}/{y}`;
    const demSource = new mlcontour.DemSource({
      url: PROXY_ABS, encoding: 'terrarium', maxzoom: 12, worker: true
    });
    demSource.setupMaplibre(maplibregl);

    // Helper: set opacity across base style layers (not our overlays)
    function setBaseStyleOpacity(map, alpha) {
      const style = map.getStyle();
      if (!style || !style.layers) return;
      for (const layer of style.layers) {
        const id = layer.id;
        const type = layer.type;

        // Skip our custom overlays so they keep independent controls
        if (['s2cloudless','color-relief','hillshade','contours','contour-text'].includes(id)) continue;

        const setIf = (prop, value) => {
          try {
            const cur = map.getPaintProperty(id, prop);
            if (cur !== undefined) map.setPaintProperty(id, prop, value);
          } catch (_) {}
        };

        switch (type) {
          case 'background': setIf('background-opacity', alpha); break;
          case 'fill': setIf('fill-opacity', alpha); break;
          case 'line': setIf('line-opacity', alpha); break;
          case 'symbol': setIf('text-opacity', alpha); setIf('icon-opacity', alpha); break;
          case 'circle': setIf('circle-opacity', alpha); break;
          case 'fill-extrusion': setIf('fill-extrusion-opacity', alpha); break;
          case 'heatmap': setIf('heatmap-opacity', alpha); break;
          case 'raster': setIf('raster-opacity', alpha); break;
          default: break;
        }
      }
    }

    // Overlay re-apply (clean, then add; contours always under topmost label)
    let currentViewMode = VIEW_MODES.THREED;
    let last3DOrientation = { ...DEFAULT_3D_ORIENTATION };
    const vignetteEl = document.querySelector('.vignette');
    const viewToggleBtn = document.getElementById('toggle3D');

    function updateViewToggle(mode) {
      if (!viewToggleBtn) return;
      const is3D = mode === VIEW_MODES.THREED;
      viewToggleBtn.classList.toggle('active', is3D);
      const nextLabel = is3D ? 'Switch to 2D' : 'Switch to 3D';
      viewToggleBtn.setAttribute('aria-pressed', String(is3D));
      viewToggleBtn.setAttribute('aria-label', nextLabel);
      viewToggleBtn.setAttribute('title', nextLabel);
    }

    function syncTerrainAndSky() {
      if (currentViewMode === VIEW_MODES.THREED) {
        if (map.getSource('terrainSource')) {
          map.setTerrain({ source: 'terrainSource', exaggeration: 1 });
        }
        map.setSky(SKY_SETTINGS);
      } else {
        map.setTerrain(null);
        map.setSky(null);
      }
      if (vignetteEl) vignetteEl.dataset.mode = currentViewMode;
    }

    const PEAK_POINTER_ID = 'peak-pointer';

    function createPeakPointerImage(color = '#3ab7c6') {
      const width = 48;
      const height = 96;
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, width, height);

      const centerX = width / 2;
      const topOffset = 8;
      const stemWidth = width * 0.16;
      ctx.strokeStyle = color;
      ctx.lineWidth = stemWidth;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(centerX, topOffset);
      ctx.lineTo(centerX, height - width * 0.28);
      ctx.stroke();

      ctx.fillStyle = color;
      const tipRadius = width * 0.24;
      ctx.beginPath();
      ctx.arc(centerX, height - tipRadius, tipRadius, 0, Math.PI * 2);
      ctx.fill();

      return ctx.getImageData(0, 0, width, height);
    }

    function ensurePeakPointerImage(map) {
      if (map.hasImage(PEAK_POINTER_ID)) return;
      const pointerImage = createPeakPointerImage();
      map.addImage(PEAK_POINTER_ID, pointerImage, { pixelRatio: 2 });
    }

    function updatePeakLabelLayer(map, layerId) {
      if (!map.getLayer(layerId)) return;
      ensurePeakPointerImage(map);

      const textField = [
        'format',
        ['coalesce', ['get', 'name:en'], ['get', 'name']],
        { 'font-scale': 1 },
        '\n',
        {},
        ['concat', ['number-format', ['get', 'ele'], { 'maximumFractionDigits': 0 }], ' m'],
        { 'font-scale': 0.85 }
      ];

      map.setLayoutProperty(layerId, 'icon-image', PEAK_POINTER_ID);
      map.setLayoutProperty(layerId, 'icon-size', 0.42);
      map.setLayoutProperty(layerId, 'icon-anchor', 'top');
      map.setLayoutProperty(layerId, 'icon-offset', [0, 0]);
      map.setLayoutProperty(layerId, 'text-anchor', 'bottom');
      map.setLayoutProperty(layerId, 'text-offset', [0, -1.4]);
      map.setLayoutProperty(layerId, 'text-field', textField);
      map.setLayoutProperty(layerId, 'text-font', ['Noto Sans Bold']);
      map.setLayoutProperty(layerId, 'text-line-height', 1.15);
      map.setLayoutProperty(layerId, 'symbol-spacing', 250);
      map.setLayoutProperty(layerId, 'text-max-width', 6);

      map.setPaintProperty(layerId, 'icon-opacity', 0.9);
      map.setPaintProperty(layerId, 'text-color', '#133540');
      map.setPaintProperty(layerId, 'text-halo-color', 'rgba(255,255,255,0.95)');
      map.setPaintProperty(layerId, 'text-halo-width', 2.2);
      map.setPaintProperty(layerId, 'text-halo-blur', 0.4);
    }

    function updatePeakLabels(map) {
      updatePeakLabelLayer(map, 'Mountain peak labels');
      updatePeakLabelLayer(map, 'Volcano peak labels');
    }

    function applyViewMode(mode, { animate = true } = {}) {
      if (mode === currentViewMode && animate) {
        // Already in requested mode; still ensure UI reflects state.
        updateViewToggle(mode);
        if (vignetteEl) vignetteEl.dataset.mode = currentViewMode;
        return;
      }

      const is3D = mode === VIEW_MODES.THREED;
      if (!is3D) {
        last3DOrientation = {
          pitch: map.getPitch(),
          bearing: map.getBearing()
        };
      }

      currentViewMode = mode;
      updateViewToggle(mode);
      if (vignetteEl) vignetteEl.dataset.mode = mode;

      const targetOrientation = is3D ? last3DOrientation : { pitch: 0, bearing: 0 };
      if (animate) {
        map.easeTo({
          pitch: targetOrientation.pitch,
          bearing: targetOrientation.bearing,
          duration: 1000
        });
      } else {
        map.setPitch(targetOrientation.pitch);
        map.setBearing(targetOrientation.bearing);
      }

      if (map.dragRotate && typeof map.dragRotate[is3D ? 'enable' : 'disable'] === 'function') {
        map.dragRotate[is3D ? 'enable' : 'disable']();
      }
      if (map.touchZoomRotate && typeof map.touchZoomRotate[is3D ? 'enableRotation' : 'disableRotation'] === 'function') {
        map.touchZoomRotate[is3D ? 'enableRotation' : 'disableRotation']();
      }

      syncTerrainAndSky();
    }

    if (viewToggleBtn) {
      viewToggleBtn.addEventListener('click', () => {
        const nextMode = currentViewMode === VIEW_MODES.THREED ? VIEW_MODES.TWOD : VIEW_MODES.THREED;
        applyViewMode(nextMode);
      });
    }

    if (vignetteEl) {
      vignetteEl.dataset.mode = currentViewMode;
    }
    updateViewToggle(currentViewMode);

    async function applyOverlays() {
      const rmL = id => { if (map.getLayer(id)) map.removeLayer(id); };
      const rmS = id => { if (map.getSource(id)) map.removeSource(id); };

      // Topmost label (symbol) layer id
      const liveLayers = map.getStyle().layers || [];
      let topLabelId = null;
      for (let i = liveLayers.length - 1; i >= 0; i--) {
        if (liveLayers[i].type === 'symbol') { topLabelId = liveLayers[i].id; break; }
      }

      // Remove layers first, then sources
      rmL('contour-text'); rmL('contours');
      rmL('hillshade'); rmL('color-relief');
      rmL('s2cloudless');
      rmS('contours'); rmS('hillshadeSource'); rmS('reliefDem'); rmS('terrainSource');
      rmS('s2cloudless');

      // Sources
      map.addSource('terrainSource', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512,
        attribution: '<a href="https://mapterhorn.com/attribution">© Mapterhorn</a>'
      });
      map.addSource('hillshadeSource', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512,
        attribution: '<a href="https://mapterhorn.com/attribution">© Mapterhorn</a>'
      });
      map.addSource('reliefDem', {
        type: 'raster-dem',
        tiles: ['mapterhorn://{z}/{x}/{y}'],
        encoding: 'terrarium',
        tileSize: 512
      });

      // Sentinel-2 Cloudless (EOX) raster overlay
      map.addSource('s2cloudless', {
        type: 'raster',
        tiles: [S2C_URL],
        tileSize: 256,
        attribution: '<a href="https://s2maps.eu/">© Sentinel-2 cloudless by EOX IT Services GmbH</a>'
      });

      // Imagery below relief/hillshade so those effects read on top
      map.addLayer({
        id: 's2cloudless',
        type: 'raster',
        source: 's2cloudless',
        paint: {
          'raster-opacity': S2_OPACITY,
          'raster-resampling': 'linear',
          'raster-fade-duration': S2_FADE_DURATION
        }
      }, topLabelId || undefined);

      // Color relief
      map.addLayer({
        id: 'color-relief',
        type: 'color-relief',
        source: 'reliefDem',
        paint: {
          'color-relief-color': [
            'interpolate', ['linear'], ['elevation'],
            0, '#254a38', 400, '#2f6b4a', 800, '#5b8f5f',
            1200, '#7fa36e', 1600, '#9eb17b',
            2000, '#b9bf8a', 2300, '#c9c38f',
            2600, '#b6ab93', 2900, '#9e978e', 3200, '#8a8a8a',
            3500, '#aeb6c0', 3800, '#cfd6de', 4100, '#f2f3f5'
          ],
          'color-relief-opacity': RELIEF_OPACITY
        }
      }, topLabelId || undefined);

      // Hillshade (anchored to map)
      map.addLayer({
        id: 'hillshade',
        type: 'hillshade',
        source: 'hillshadeSource',
        paint: {
          'hillshade-illumination-anchor': 'map',
          'hillshade-illumination-direction': [270, 315, 0, 45],
          'hillshade-illumination-altitude': [30, 30, 30, 30],
          'hillshade-exaggeration': 0.22,
          'hillshade-highlight-color': 'rgba(255,255,255,0.85)',
          'hillshade-shadow-color':   'rgba(0,0,0,0.55)'
        }
      }, topLabelId || undefined);

      // Contours
      map.addSource('contours', {
        type: 'vector',
        tiles: [
          demSource.contourProtocolUrl({
            multiplier: 1,
            thresholds: { 11:[60,300], 12:[30,150], 13:[30,150], 14:[15,60], 15:[6,30] },
            elevationKey: 'ele', levelKey: 'level', contourLayer: 'contours'
          })
        ],
        maxzoom: 16
      });

      map.addLayer({
        id: 'contours',
        type: 'line',
        source: 'contours',
        'source-layer': 'contours',
        layout: { 'line-join': 'round' },
        paint: {
          'line-color': 'rgba(0,0,0,0.55)',
          'line-width': ['match', ['get', 'level'], 1, 1, 0.5],
          'line-opacity': ['interpolate', ['linear'], ['zoom'], 13.4, 0, 13.5, 0.45, 15, 0.85, 17, 1]
        }
      });
      map.addLayer({
        id: 'contour-text',
        type: 'symbol',
        source: 'contours',
        'source-layer': 'contours',
        filter: ['>', ['get', 'level'], 0],
        layout: {
          'symbol-placement': 'line',
          'text-anchor': 'center',
          'text-size': 10,
          'text-field': ['concat', ['number-format', ['get', 'ele'], { 'maximumFractionDigits': 0 }], ' m'],
          'text-font': ['Noto Sans Bold']
        },
        paint: {
          'text-halo-color': 'white',
          'text-halo-width': 1,
          'text-opacity': ['interpolate', ['linear'], ['zoom'], 13.4, 0, 13.6, 0.5, 14.2, 0.9]
        }
      });
      if (topLabelId) {
        map.moveLayer('contours', topLabelId);
        map.moveLayer('contour-text', topLabelId);
      }

      ensureGpxLayers(map, currentGpxData, topLabelId);

      const symbolLayers = (map.getStyle().layers || []).filter(l => l.type === 'symbol');
      symbolLayers.forEach(l => map.moveLayer(l.id));

      // Sky/Fog / Terrain sync with view mode
      syncTerrainAndSky();

      // Reflect S2 toggle state
      const s2Btn = document.getElementById('toggleS2');
      if (s2Btn) {
        const vis = (map.getLayoutProperty('s2cloudless', 'visibility') || 'visible') !== 'none';
        s2Btn.classList.toggle('active', vis);
      }

      // Apply current base opacity to all base layers after style is ready
      setBaseStyleOpacity(map, 1);
      updatePeakLabels(map);
    }

    // After the style loads, wire overlays
    map.on('style.load', applyOverlays);

    // Hillshade method switcher
    const methodButtons = Array.from(document.querySelectorAll('.hs-panel .btn'));
    const DEFAULT_METHOD = 'igor';
    function setHillshadeMethod(method) {
      methodButtons.forEach(b => b.classList.toggle('active', b.dataset.method === method));
      if (!map.getLayer('hillshade')) return;

      map.setPaintProperty('hillshade', 'hillshade-illumination-anchor', 'map');
      map.setPaintProperty('hillshade', 'hillshade-illumination-direction', [270, 315, 0, 45]);
      map.setPaintProperty('hillshade', 'hillshade-illumination-altitude', [30, 30, 30, 30]);
      map.setPaintProperty('hillshade', 'hillshade-method', method);

      if (method === 'combined') {
        map.setPaintProperty('hillshade', 'hillshade-exaggeration', 0.23);
        map.setPaintProperty('hillshade', 'hillshade-highlight-color', 'rgba(255,255,255,0.88)');
        map.setPaintProperty('hillshade', 'hillshade-shadow-color',   'rgba(0,0,0,0.58)');
      } else { // igor
        map.setPaintProperty('hillshade', 'hillshade-exaggeration', 0.24);
        map.setPaintProperty('hillshade', 'hillshade-highlight-color', 'rgba(255,255,255,0.9)');
        map.setPaintProperty('hillshade', 'hillshade-shadow-color',   'rgba(0,0,0,0.6)');
      }
    }
    methodButtons.forEach(btn => btn.addEventListener('click', () => setHillshadeMethod(btn.dataset.method)));
    map.once('style.load', () => setHillshadeMethod(DEFAULT_METHOD));

    // Ensure initial mode is synced without animation once map is ready
    map.once('style.load', () => applyViewMode(currentViewMode, { animate: false }));

    // S2 Cloudless toggle
    const s2Btn = document.getElementById('toggleS2');
    if (s2Btn) {
      s2Btn.addEventListener('click', () => {
        if (!map.getLayer('s2cloudless')) return;
        const vis = map.getLayoutProperty('s2cloudless', 'visibility') || 'visible';
        const next = vis === 'none' ? 'visible' : 'none';
        map.setLayoutProperty('s2cloudless', 'visibility', next);
        s2Btn.classList.toggle('active', next === 'visible');
      });
    }
    // Initial base is VersaTiles; overlays apply on first style.load.
  })();
</script>
</body>
</html>




